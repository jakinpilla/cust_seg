---
title: "ADP 8회 1번 문제 풀이"
author: "Kim Jeong Gyu"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
  html_document:
    theme: cerulean
    toc: yes
    toc_depth: 3
---

<style type="text/css">

body{ /* Normal  */
      font-size: 11px;
  }
td {  /* Table  */
  font-size: 9px;
}
h1.title {
  font-size: 38px;
  color: DarkRed;
}
h1 { /* Header 1 */
  font-size: 28px;
  color: DarkBlue;
}
h2 { /* Header 2 */
    font-size: 22px;
  color: DarkBlue;
}
h3 { /* Header 3 */
  font-size: 18px;
  color: DarkBlue;
}
h4 { /* Header 4 */
  font-size: 14px;
  color: DarkBlue;
}
code.r{ /* Code block */
    font-size: 11px;
}
pre { /* Code block - determines code spacing between lines */
    font-size: 10px;
}
</style>


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### 1. transaction 데이터를 읽고 파생변수 정의하기

 - 데이터 읽고 sale 변수에 저장

```{r}
sale <- read.csv('transaction.csv', stringsAsFactors = F)
str(sale)
```
 
 - RFM 분석 실시
 - RFM 분석을 위해 시간 데이터 형식 POSIXct 형식으로 변경
 
```{r}
library(plyr)
library(dplyr)
sale %>% mutate(ymd_time  = paste(ymd, time)) -> sale
sale$ymd_time <- as.POSIXct(sale$ymd_time)
head(sale[, c(7, 2, 3, 4, 5, 6)])
```

- RFM 분석을 위해 데이터 내 일시가 일치하는 레코드의 중복을 제거, df_F에 저장
- df_F 에서 'ymd(년월일)', 'time(00:00)', 'custid' 등을 식ㅂ

```{r}
sale %>% mutate(ymd_time_custid = paste(ymd, time, custid)) %>% 
  distinct(ymd_time_custid) -> df_F ## distinct 함수를 이용 중복 제거

df_F %>% mutate(ymd = substr(ymd_time_custid, 1, 10), 
                time = substr(ymd_time_custid, 12, 16), 
                custid = substr(ymd_time_custid, 18, 22)) -> df_F

NROW(df_F) ## 총 2089명의 고객별
head(df_F)
```

-  df_F에서 고객별로 묶어 행의 갯수를 세어 해당 고객의 총 방문회수를 구함, userF에 저장

```{r}
df_F %>% group_by(custid) %>% summarise(frequency = n()) -> userF
str(userF)
```

- 한편 sale 데이터에서 가장 최근 방문일자 및 최초 방문일자 및 방문기간 등을 계산하여  userRFM 변수에 저장

```{r}
max(sale$ymd_time)
min(sale$ymd_time)

sale %>% group_by(custid) %>% 
  summarise(minRecency = min(ymd_time),
            recency = max(ymd_time),
            monetary = sum(amt), 
            period = as.numeric(max(ymd_time) - min(ymd_time))) -> userRFM

## period는 일수로 계산되어짐.

head(userRFM)
nrow(userRFM) ## 2089명의 고객
```

- userRFM과 userF를 join

```{r}
userRFM <- left_join(userRFM, userF)

head(userRFM)
```

 - 날짜 연산을 위해 고객별 최초 방문일자 및 최근 방문일자를 변수로 추가하여 userRFM에 추가
 
```{r}

## 고객별 최초 방문 일자
userRFM$minDate <- as.Date(userRFM$minRecency, origin="1970-01-01")

## 고객별 최근 방문 일자
userRFM$maxDate <- as.Date(userRFM$recency, origin="1970-01-01")

head(userRFM)
```

- 고객들의 최근 방문 일자에 대한 히스토그램

```{r}
hist(userRFM$maxDate, breaks=100, main = 'Guest Recency') 
```

- 최근 방문일자(maxDate) 별 고객들의 빈도수를 시각화

```{r}
plot(table(userRFM$maxDate), main="Guests Frequency")
## 전체 고객중 최근 방분한 고객들이 많은 비중을 차지
```

```{r}
head(table(userRFM$maxDate))
```

- 고객별 총 지출금액에 대한 시각화
- 고객별 총 지출금액에 대한 히스토그램

```{r}
range(userRFM$monetary) 
## 지출 금액의 범위는 40~827854 까지 많은 차이가 있음

hist(userRFM$monetary, breaks=100, main = 'Guest Monetary') 
## 대부분은 소규모 구매, 몇몇 많은 금액을 지출하는 고객들이 있음
```

##### RFM(Recency, Frequency, Monetary)별로 상위 20%가 차지하는 총 매출액 비중 구하기

 - 총 매출액(sumTotal)
 
```{r}
sumTotal <- sum(userRFM$monetary)
sumTotal
```

- 1. Recency 별 상위 20%가 차지하는 매출액 비중 구하기
- recency(max(ymd_time))의 분위수 할당 후 결과 보기
- 날짜를 numeric으로 변환 후 분위수를 0.2, 0.4, 0.6, 0.8로 할당

```{r}
as.numeric(head(userRFM$recency))

## 1970-01-01 00:00:00을 기준으로 몇 초가 지났는지를 표시
```

```{r}
quantile(as.numeric(userRFM$recency), c(0.2, 0.4, 0.6, 0.8))
```

- 1. recency 상위 20%의 매출액의 비중 구하기

- recency 상위 20%의 매출액 합계( = sumR) 구하기

```{r}
top20_recency_monetary <- userRFM$monetary[userRFM$recency > quantile(userRFM$recency, 0.8)]
sum.top20_recency_monetary <- sum(as.numeric(top20_recency_monetary))
sumR <- sum.top20_recency_monetary
sumR
```

 - recency 상위 20%의 비중은...
 
```{r}
sumR / sumTotal 
```

- 그러므로 recency 상위 20%의 비중은 약 43%임.

- 2. frequency 상위 20%가 차지하는 매출액 비중 구하기

```{r}
head(userRFM$frequency)
quantile(as.numeric(userRFM$frequency), c(0.2, 0.4, 0.6, 0.8))
sumF <- sum(userRFM$monetary[userRFM$frequency > quantile(userRFM$frequency, 0.8)])
sumF / sumTotal
```
- frequency 상위 20%가 차지하는 매출액 비중은 약 59%

- 3.monetary 상위 20%가 차지하는 매출액 비중 구하기

```{r}
sumM <- sum(userRFM$monetary[userRFM$monetary > quantile(userRFM$monetary, 0.8)])
sumM / sumTotal
```

- monetary 상위 20%가 차지하는 매출액 비중은 약 64%

- 고객별 RFM score는 RFM 분야별 등급 점수에 가중치를 곱한 후 합산하여 산출

- RFM 별 가중치 구하기

```{r}
weightR<- sumR / (sumR + sumF + sumM) ## 0.256983
weightF <- sumF / (sumR + sumF + sumM) ## 0.3554946
weightM <- sumM / (sumR + sumF + sumM) ## 0.3875224
weightR + weightF + weightM ## 1 확인
```

- RFM 별 고객점수 나누는 기준 구하기

```{r}
## recency quantile
quantR <- quantile(as.numeric(userRFM$recency), c(0, 0.2, 0.4, 0.6, 0.8, 1), origin = '1970-01-01 00:00:00')

## frequency guantile
quantF <- quantile(userRFM$frequency, c(0, 0.2, 0.4, 0.6, 0.8, 1))

## monetary quantitle
quantM <- quantile(userRFM$monetary, c(0, 0.2, 0.4, 0.6, 0.8, 1))
```

- 고개별 R score 구하기

```{r}
quantR
num_recency <- as.numeric(userRFM$recency)
userRFM_1 <- cbind(userRFM, recency_num = num_recency)
userRFM_1 %>% 
  mutate(R = ifelse(recency_num >= quantR[1] & recency_num < quantR[2], 1,
                    ifelse(recency_num >= quantR[2] & recency_num < quantR[3], 2,
                           ifelse(recency_num >= quantR[3] & recency_num < quantR[4], 3,
                                  ifelse(recency_num >= quantR[4] & recency_num < quantR[5], 4, 5))))) -> added_R
head(added_R)
```

- 고객별 F score 구하기

```{r}
quantF

userRFM %>% 
  mutate(F = ifelse(frequency >=  quantF[1] & frequency < quantF[2], 1, 
                    ifelse(frequency >= quantF[2] & frequency < quantF[3], 2, 
                           ifelse(frequency >= quantF[3] & frequency < quantF[4], 3,
                                  ifelse(frequency >= quantF[4] & frequency < quantF[5], 4, 5))))) -> added_F
head(added_F)
```


- 고객별 M score 구하기

```{r}
quantM[1]
quantM

userRFM %>% 
  mutate(M = ifelse(monetary >=  quantM[1] & monetary < quantM[2], 1, 
                    ifelse(monetary >= quantM[2] & monetary < quantM[3], 2, 
                           ifelse(monetary >= quantM[3] & monetary < quantM[4], 3,
                                  ifelse(monetary >= quantM[4] & monetary < quantM[5], 4, 5))))) -> added_M
head(added_M)
```

```{r}
userRFM <- cbind(userRFM, R = added_R$R, F = added_F$F, M = added_M$M)
head(userRFM)
```

- score 계산

```{r}
userRFM$score <- (weightR * userRFM$R + weightF * userRFM$F + weightM * userRFM$M)*100/5
head(userRFM)
```

- score 점수 시각화(histogram)
```{r}
hist(userRFM$score, breaks = 50, main = 'RFM score')
```

- 그러므로, 분석을 위한 파생변수 R(최근 거래 등급 점수), F(거래 빈도 등급 점수), M(매출 등급 점수), score(각 지수별 가중치 고려한 고객별 종합 점수) 등을 정의하였음.

### 1.2 군집분석

 - R, F, M 3가지 변수를 각각 3.3과 1.7을 기준으로 High - Middle - Low로 구분, 총 9가지의 경우의 수가 발생한다는 점에 착안 k=9로 하여 kmeans 군집 분석 시행
 
```{r}
k_9_means_RFM <- kmeans(userRFM[, c('R', 'F', 'M')], 9)
k_9_means_RFM
```

 - Cluster means:
 -          R        F        M
 - cluster 1 : 4.282051 3.205128 2.846154
 - cluster 2 : 1.357009 2.061682 1.534579
 - cluster 3 : 2.833333 4.398810 4.434524
 - cluster 4 : 4.585774 4.347280 3.849372
 - cluster 5 : 1.536913 3.651007 3.550336
 - cluster 6 : 3.622120 2.018433 1.368664
 - cluster 7 : 2.595745 3.265957 2.611702
 - cluster 8 : 4.625749 4.886228 5.000000
 - cluster 9 : 2.504854 2.155340 3.398058

 \ 
 
 -  3.3과 1.7을 기준
 
 -             R   F   M
 - cluster 1 : H   M   M : Hi고객 : 최근 방문, 어느정도 방문횟수가 있고 지출하는 고객
 - cluster 2 : L   M   M : OB고객 : 옛날 고객
 - cluster 3 : M   H   H : Hey.come.on 고객 : 우수고객이었으나 최근에 오지 않는 고객
 - cluster 4 : H   H   H : VIP : 우수고객
 - cluster 5 : L   H   H : plz.dont.go 고객 : 우수고객이나 한 동안 오지 않는 고객
 - cluster 6 : H   M   L : just_Hi : 잠깐 왔다갔다 하는 고객
 - cluster 7 : M   M   M : Normal : 모든지 중간은 하는 고객
 - cluster 8 : H   H   H : VVIP : 최우수고객
 - cluster 9 : M   M   H : Poten : 잠재적인 우수 고개
 

 - 그러므로, 고객을 9개의 클러스터로 세분화하였으며 상기와 같이 세분화된 고객집단에 대한 LABEL 작성하였음.
 
### 1.3 군집분석 결과 시각화, 마케팅 인사이트 도출

```{r}
userRFM$cluster <- k_9_means_RFM$cluster
```

- 각 클러스터별 고객 수 계산

```{r}
table(userRFM$cluster)
```

- 시각화를 위해 상기 table를 data.frame 형식으로 변경

```{r}
df_1 <- as.data.frame(table(userRFM$cluster)) 
names(df_1) <- c('cluster', 'freq')
head(df_1)
str(df_1)
```

```{r}
library(ggplot2)
bp <- ggplot(df_1, aes(x = '', y = freq, fill = cluster)) + geom_bar(width = 1, stat = 'identity')
pie <- bp + coord_polar('y', start = 0)
pie + scale_fill_discrete(name="Cluster", labels=c("Hi", "OB", "Hey.come.on", "VIP", "plz.dont.go", "just.hi", "Normal", "VVIP", "Poten"))
```

- cluster 별 고객들의 매출 비율 pie graph 그리기

```{r}
userRFM %>% group_by(cluster) %>% summarise(sum.money.cluster = sum(monetary)) -> sum.money.by.cluster.df
sum.money.by.cluster.df$cust.count <- df_1$freq
sum.money.by.cluster.df
```

```{r}
as.data.frame(prop.table(sum.money.by.cluster.df$sum.money.cluster)) -> prop.sum.money
cbind(sum.money.by.cluster.df  , prop.sum.money) -> df_4
df_name <- data.frame(cluster.name = c("Hi", "OB", "Hey.come.on", "VIP", "plz.dont.go", "just.hi", "Normal", "VVIP", "Poten"))
df_5 <- cbind(df_4, df_name)
df_5[, c(1, 5, 3, 2, 4)]
names(df_4) <- c('cluster', 'sum.money', 'money.prop')
df_4$cluster <- as.factor(df_4$cluster)
bp_1 <- ggplot(df_4, aes(x = '', y = money.prop, fill = cluster)) + geom_bar(width = 1, stat = 'identity')
pie <- bp_1 + coord_polar('y', start = 0)
pie + scale_fill_discrete(name="Cluster", labels=c("Hi", "OB", "Hey.come.on", "VIP", "plz.dont.go", "just.hi", "Normal", "VVIP", "Poten"))
```

- 마케팅 인사이트 : VVIP와 VIP 고객의 비율이 약 66% 이므로 이들에 대한 차별화된 서비스 제공하여 매출을 유지 및 시켜야 하고, 한편 OB 집단의 매출 비율이 16%로 높은 편이어서 이들이 다시 다시 구매할 수 있도록 유도하는 마케팅 전략이 필요함. OB 고객 535명에 대해 구매제품 종류 및 제품수명주기 고려 캠페인, 이벤트 등을 실시하는 전략이 필요함.

 - VVIP(cluster 8번) : 최우수고객이며 차별화된 서비스 제공 필요
 - VIP(cluster 4번) : 잠재적 VVIP 고객이 되도록 고급 정보, 적극적 오퍼링 등 제공 필요
 - OB(cluster 2번) : 구매제품 종류 및 제품수명주기 고려 캠페인, 이벤트 전략 등 필요
 - plz.dont.go(cluster 5번) : R(최근방문) 지수 상승 유도 필요. 구매제품 종류 및 제품수명주기 고려 캠페인, 이벤트 전략 등 필요
 - hi(cluster 1번) : 최근 방문한 고객, 할인행사 등 일반정보 제공 필요, 친 브랜드화 전략 필요

